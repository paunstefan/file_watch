#![allow(non_upper_case_globals)]

use std::{
    collections::HashMap,
    ffi::CString,
    fs::File,
    io::{Cursor, Read},
    ops::BitAnd,
    os::unix::prelude::{AsRawFd, FromRawFd, OsStrExt},
    path::PathBuf,
};

use bitflags::bitflags;
use byteorder::{NativeEndian, ReadBytesExt};
use libc::c_int;

use crate::errors::Error;
use crate::utils::*;

bitflags! {
    /// Event mask bitflags
    pub struct EventTypes: u32 {
        /// File or directory was opened
        const Open = libc::IN_OPEN;
        /// File or directory was closed
        const Close = libc::IN_CLOSE;
        /// File was modified
        const Modify = libc::IN_MODIFY;
        /// File or directory was itself deleted
        const Deleted = libc::IN_DELETE_SELF;
        /// File was accessed
        const Access = libc::IN_ACCESS;
        /// File or directory was moved/renamed
        const Move = libc::IN_MOVE;
        /// Metadata changed
        const ChangeAttributes = libc::IN_ATTRIB;
        /// File or directory was created inside watched directory
        const CreatedInDir = libc::IN_CREATE;
        /// File or directory was deleted inside watched directory
        const DeletedInDir = libc::IN_DELETE;
    }
}

/// Struct containing an event that happened to a file
#[derive(Debug)]
pub struct Event {
    /// Name of the file/directory whose watch generated the event
    pub file: PathBuf,
    /// Event type
    pub ev_type: EventTypes,
    /// Name of the file/directory which generated an event
    /// inside a watched directory
    /// Only filled when a directory is watched
    pub name: Option<String>,
    /// True if event generated by a directory
    pub is_dir: bool,
    /// True if the filesystem on which the file/directory is located
    /// was unmounted
    pub unmounted: bool,
    /// True if the watch was removed
    pub removed: bool,
}

impl Event {
    /// Create new event
    fn new(file: PathBuf, ev_type: EventTypes, name: Option<String>) -> Self {
        let is_dir = ev_type.bits() & libc::IN_ISDIR > 0;
        let unmounted = ev_type.bits() & libc::IN_UNMOUNT > 0;
        let removed = ev_type.bits() & libc::IN_IGNORED > 0;

        // ev_type argument can contain other bits that are not included in the
        // EventTypes, so they should be cleared before returning to user.
        let ev_type = ev_type.bitand(EventTypes::all());

        Event {
            file,
            ev_type,
            name,
            is_dir,
            unmounted,
            removed,
        }
    }
}

/// Wrapper struct for an inotify instance
#[derive(Debug)]
pub struct Watcher {
    fd: File,
    #[cfg(feature = "tokio")]
    async_fd: tokio::fs::File,
    watches: HashMap<c_int, PathBuf>,
}

const MAX_FILE_LEN: usize = 255;
const EVENT_LEN: usize = std::mem::size_of::<libc::inotify_event>() + MAX_FILE_LEN + 1;

impl Watcher {
    /// Create a new Watcher instance
    ///
    /// Internally is represented as an `inotify` instance
    /// inside the kernel
    pub fn init() -> Result<Self, Error> {
        let fd = unsafe { libc::inotify_init() };

        dbg!(fd);

        // Negative value on error
        if fd < 0 {
            return Err(Error::InotifyInit);
        }

        let fd = unsafe { File::from_raw_fd(fd) };

        #[cfg(feature = "tokio")]
        let async_fd = tokio::fs::File::from_std(fd.try_clone().unwrap());

        Ok(Watcher {
            fd,
            #[cfg(feature = "tokio")]
            async_fd,
            watches: HashMap::new(),
        })
    }

    /// Add watch to a file or directory
    ///
    /// A watch consists of a file and a series of events
    /// to watch for. When any of the events happen, the
    /// watcher will be notified.
    ///
    /// Returns a watch descriptor
    pub fn add_watch(&mut self, file_path: PathBuf, events: EventTypes) -> Result<i32, Error> {
        let cstring = CString::new(file_path.as_os_str().as_bytes()).map_err(|_x| Error::Other)?;

        let wd = unsafe {
            libc::inotify_add_watch(self.fd.as_raw_fd(), cstring.as_ptr(), events.bits())
        };

        if wd < 0 {
            let errno = get_errno().expect("Can't get errno value.");
            return Err(Error::AddWatch(errno_string(errno)));
        }

        self.watches.insert(wd, file_path);

        Ok(wd)
    }

    /// Blocks until an event is received for a configured watch
    pub fn wait_for_event(&mut self) -> Result<Event, Error> {
        let mut buffer = vec![0; EVENT_LEN];

        let read_count = self.fd.read(&mut buffer).map_err(Error::IOError)?;

        if read_count < std::mem::size_of::<libc::inotify_event>() {
            return Err(Error::WaitEvent);
        }

        parse_event(buffer, self)
    }

    #[cfg(feature = "tokio")]
    /// Nonblocking wait for the events
    pub async fn wait_for_event_async(&mut self) -> Result<Event, Error> {
        use tokio::io::AsyncReadExt;
        let mut buffer = vec![0; EVENT_LEN];

        let read_count = self
            .async_fd
            .read(&mut buffer)
            .await
            .map_err(Error::IOError)?;

        if read_count < std::mem::size_of::<libc::inotify_event>() {
            return Err(Error::WaitEvent);
        }
        dbg!(read_count);
        parse_event(buffer, self)
    }

    /// Remove watch from a file
    ///
    /// `wd` is the descriptor returned by `add_watch`
    pub fn remove_watch(&mut self, wd: i32) -> Result<(), Error> {
        let rc = unsafe { libc::inotify_rm_watch(self.fd.as_raw_fd(), wd) };

        if rc < 0 {
            let errno = get_errno().expect("Can't get errno value.");

            return Err(Error::RemoveWatch(errno_string(errno)));
        }

        self.watches.remove(&wd);

        Ok(())
    }
}

fn parse_event(buffer: Vec<u8>, watcher: &mut Watcher) -> Result<Event, Error> {
    let mut rdr = Cursor::new(buffer);

    let event = {
        let wd = rdr.read_i32::<NativeEndian>().unwrap();
        let mask = rdr.read_u32::<NativeEndian>().unwrap();
        let cookie = rdr.read_u32::<NativeEndian>().unwrap();
        let len = rdr.read_u32::<NativeEndian>().unwrap();
        libc::inotify_event {
            wd,
            mask,
            cookie,
            len,
        }
    };

    let name = if event.len > 0 {
        let mut name = vec![0; event.len as usize];
        rdr.read_exact(&mut name).map_err(Error::IOError)?;
        let name: String = name
            .iter()
            .take_while(|b| **b != 0)
            .map(|b| *b as char)
            .collect();
        Some(name)
    } else {
        None
    };

    // Safety: all bits fit into the 32bit number. Unchecked is needed because
    // some flags that can't be set by the user can be returned by the API
    let flags = unsafe { EventTypes::from_bits_unchecked(event.mask) };

    let my_event = Event::new(watcher.watches.get(&event.wd).unwrap().clone(), flags, name);

    if my_event.removed {
        watcher.watches.remove(&event.wd);
    }

    Ok(my_event)
}
